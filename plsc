#!/usr/bin/env python

import sys
import yaml, re
import ldap

import util
from connection import Connection

from jumpcloud import JumpCloud

global jumpcloud


def add_ldap_structure(config, dst_ldap, o, displayName):
    o_entry = {
        'objectClass': ['top', 'organization', 'extensibleObject'],
        'o': [o],
        'displayName': [displayName]
    }
    dst_ldap.add("o={},ou=COs,{}".format(o, dst_ldap.basedn), o_entry)

    o_dn = "o={},ou=COs,{}".format(o, dst_ldap.basedn)
    for ou in ['Groups', 'People', 'Sequence']:
        ou_dn = "ou={},{}".format(ou, o_dn)
        ou_entry = {
            'objectClass': ['organizationalUnit', 'top'],
            'ou': [ou]
        }
        dst_ldap.add(ou_dn, ou_entry)

    for seq_number in ['uid', 'gid']:
        uid_dn = 'cn={}NumberSequence,ou=Sequence,{}'.format(seq_number, o_dn)
        uid_entry = {
            'objectClass': ['top','device'],
            'serialNumber': [str(read_key_from_config(config, seq_number))]
        }
        dst_ldap.add(uid_dn, uid_entry)


def retrieve_all_dest_organisations(l):
    dns = l.rfind("ou=COs", "o=*", ['o'])

    s = set()
    for v in dns.values():
        s.add(v['o'][0])

    return s


def build_dst_skeleton(config, dst_ldap, collaborations):
    src_o = set()
    for k in collaborations.keys():
        src_o.add(util.dn2rdns(k)['o'][0])

    dst_o = retrieve_all_dest_organisations(dst_ldap)

    print(dst_o)
    for o in sorted(src_o - dst_o):
        # print("Syncing CO: {}".format(o))
        displayName = collaborations['o={},dc=https://rsc-authz.in.test.surfresearchcloud.nl/saml/metadata,dc=pilot-services,dc=scz,dc=lab,dc=surf,dc=nl'.format(o)]['description']
        add_ldap_structure(config, dst_ldap, o, displayName)


def get_collaboration_for_service(connection, service):
    """ Given a service determine all COs that are part of it
    and return the found COs.

    Arguments:
        connection - An LDAP connection.
        service    - Service to find COs for

    Return:
        Dict of COs and their displayName.
    """

    r = connection.find(None,
                        "(&(objectClass=organization)(o=*))",
                        ['o', 'description'],
                        ldap.SCOPE_ONELEVEL
                       )
    cos = {}

    for dn, attributes in r.items():
        co_id = dn

        l = {}
        for name, value in attributes.items():
            if 'description' in name:
                l[name] = value[0]

        cos["{}".format(co_id)] = l

    return cos


def read_config_file():
    """Read a YAML config file."""

    if len(sys.argv) < 2:
        print("Missing config file.")
        print("usage: {} <config_file.yml>".format(sys.argv[0]))
        sys.exit(2)

    with open(sys.argv[1]) as f:
        config = yaml.safe_load(f)

    return config


def read_key_from_config(config, key):
    """
    Recursively find the key in the config file and return the
    associated value.
    """

    if type(key) is str:
        if key not in config:
            raise KeyError("{} not found in config file.".format(key))
        return config[key]

    k, v = next(iter(key.items()))
    a = read_key_from_config(config[k], v)

    return a


def get_service_from_config(config):
    """Get the service identifier from the config."""
    value = read_key_from_config(config, {'ldap': {'src': 'basedn'}})

    return util.dn2rdns(value)['dc'][0]


persons = {}

def generate_dest_people_entry_from_src_entry(dn, attributes):
    rdns = util.dn2rdns(dn)
    uid = rdns['uid'][0]

    dst_entry = {}
    dst_entry['objectClass'] = ['inetOrgPerson', 'person', 'posixAccount']
    dst_entry['uid'] = [uid]
    dst_entry['cn'] = attributes['cn']
    dst_entry['sn'] = attributes['sn']
    dst_entry['homeDirectory'] = attributes['homeDirectory']
    dst_entry['uidNumber'] = attributes['uidNumber']
    dst_entry['gidNumber'] = attributes['gidNumber']

    if 'givenName' in attributes:
        dst_entry['givenName'] = attributes['givenName']

    if 'sshPublicKey' in attributes:
        dst_entry['objectClass'].append('ldapPublicKey')
        dst_entry['sshPublicKey'] = attributes['sshPublicKey']

    if 'eduPersonPrincipalName' in attributes:
        dst_entry['objectClass'].append('eduPerson')
        dst_entry['eduPersonPrincipalName'] = attributes['eduPersonPrincipalName']

    if 'mail' in attributes:
        dst_entry['mail'] = attributes['mail']

    return uid, dst_entry


def generate_dest_group_entry_from_src_entry(attributes):
    dst_entry = {}
    cn = attributes['cn'][0]
    dst_entry['objectClass'] = ['posixGroup']
    dst_entry['gidNumber'] = attributes['gidNumber']
    dst_entry['cn'] = [cn]

    members = []

    if 'sczMember' in attributes:
        for i in attributes['sczMember']:
           rdns = util.dn2rdns(i)
           if 'uid' in rdns:
             uid = rdns['uid'][0]
             members.append(uid)

    return dst_entry, members


def update_or_add_dest_people_entry(src_ldap, dst_ldap, src_entry, o):
    """
    Update the people entry at the destionion, or in case it does
    not exists, add it instread.
    """

    #NOTE: If the people entry does exists at the destionion, but
    #      has been removed from the source people entry, it is
    #      not removed here.

    for dn, attributes in src_entry.items():
        uid, dst_entry = generate_dest_people_entry_from_src_entry(dn, attributes)

        # Store this user in temporary cache, for later use when we need to instantiate JumpCloud User
        # based on these same attributes
        persons[uid] = dst_entry

        # Now continue with provisioning the LDAP
        dst_dns = dst_ldap.rfind(
            "ou=People,o={},ou=COs".format(o),
            "(&(objectClass=person)(uid={}))".format(uid)
        )

        if len(dst_dns) == 1:
            dst_dn, old_entry = list(dst_dns.items())[0]

            dst_ldap.modify(dst_dn, old_entry, dst_entry)
        elif len(dst_dns) == 0:
            dst_dn = "uid={},ou=People,o={},ou=COs,{}".format(
                uid,
                o,
                dst_ldap.basedn
            )
            dst_ldap.add(dst_dn, dst_entry)
        else:
            print("Too many destination dns.")


def update_or_add_dest_group_entry(src_dns, dst_ldap, o):
    for _, attributes in src_dns.items():
        dst_entry, members = generate_dest_group_entry_from_src_entry(attributes)

        group = attributes['cn'][0]

        dst_dn = "cn={},ou=Groups,o={},ou=COs,{}".format(
            group,
            o,
            dst_ldap.basedn
        )

        # Process JumpCloud Persons & Groups
        # These are only provisoned for a specific Athorisation Group
        try:
            if group == read_key_from_config(config, {'api': 'auth_group'}):
                # Step 1. Provison the Persons
                for uid in members:
                    jumpcloud.person(**persons[uid])

                # Step 2. Provision the Group
                jumpcloud.group(group, members)
        except Exception as e:
            print("Skipping JumpCloud because of: {}".format(e))

        if len(members) > 0:
           dst_entry['memberUid'] = []

           for uid in members:
             dst_entry['memberUid'].append(uid)

        dst_group = dst_ldap.find(dst_dn)

        if len(dst_group) == 0:
            dst_ldap.add(dst_dn, dst_entry)
        else:
            _, old_entry = list(dst_group.items())[0]
            dst_ldap.modify(dst_dn, old_entry, dst_entry)


def sync_rsc_with_scz(src_ldap, dst_ldap, collaborations):
    """
    Loop over all the collaborations and sync them one by one.
    """
    for k,_ in collaborations.items():
        o = util.dn2rdns(k)['o'][0]

        src_entry = src_ldap.rfind(
            "ou=People,o={}".format(o),
            "(objectClass=person)"
        )

        update_or_add_dest_people_entry(src_ldap, dst_ldap, src_entry, o)

        src_dns = src_ldap.rfind(
            "ou=Groups,o={}".format(o),
            "(objectClass=posixGroup)",
            ['gidNumber', 'cn', 'sczMember']
        )

        update_or_add_dest_group_entry(src_dns, dst_ldap, o)


if __name__ == "__main__":
    """
    Connect to both the source and destination LDAP and sync the two.
    """

    config = read_config_file()

    src_ldap = Connection(read_key_from_config(config, {'ldap': 'src'}))
    dst_ldap = Connection(read_key_from_config(config, {'ldap': 'dst'}))

    jumpcloud = None

    try:
        jumpcloud = JumpCloud(
           read_key_from_config(config, {'api': 'url'}),
           read_key_from_config(config, {'api': 'key'})
        )

        # print(jumpcloud)
    except Exception as e:
        print("Skipping jumpcloud because of: {}".format(e))


    service = get_service_from_config(config)
    collaborations = get_collaboration_for_service(src_ldap, service)

    build_dst_skeleton(config, dst_ldap, collaborations)

    sync_rsc_with_scz(src_ldap, dst_ldap, collaborations)


    if jumpcloud is not None:
        # print(jumpcloud)
        jumpcloud.cleanup()
