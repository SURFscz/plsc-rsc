#!/usr/bin/env python

import sys
import yaml, re
import ldap

import util
from connection import Connection


def add_ldap_structure(config, dst_ldap, o, displayName):
    o_entry = {
        'objectClass': ['top', 'organization', 'extensibleObject'],
        'o': [o],
        'displayName': [displayName]
    }
    dst_ldap.add("o={},ou=COs,{}".format(o, dst_ldap.basedn), o_entry)

    o_dn = "o={},ou=COs,{}".format(o, dst_ldap.basedn)
    for ou in ['Groups', 'People', 'Sequence']:
        ou_dn = "ou={},{}".format(ou, o_dn)
        ou_entry = {
            'objectClass': ['organizationalUnit', 'top'],
            'ou': [ou]
        }
        dst_ldap.add(ou_dn, ou_entry)

    for seq_number in ['uid', 'gid']:
        uid_dn = 'cn={}NumberSequence,ou=Sequence,{}'.format(seq_number, o_dn)
        uid_entry = {
            'objectClass': ['top','device'],
            'serialNumber': [str(read_key_from_config(config, seq_number))]
        }
        dst_ldap.add(uid_dn, uid_entry)


def retreive_all_dest_organisations(l):
    dns = l.rfind("ou=COs", "o=*", ['o'])

    s = set()
    for v in dns.values():
        s.add(v['o'][0])

    return s


def build_dst_skeleton(config, dst_ldap, collaborations):
    src_o = set()
    for k in collaborations.keys():
        src_o.add(util.dn2rdns(k)['o'][0])

    dst_o = retreive_all_dest_organisations(dst_ldap)

    for o in sorted(src_o - dst_o):
        # print("Syncing CO: {}".format(o))
        displayName = collaborations['o={},dc=https://rsc-authz.in.development.surfresearchcloud.nl/saml/metadata,dc=pilot-services,dc=scz,dc=lab,dc=surf,dc=nl'.format(o)]['description']
        add_ldap_structure(config, dst_ldap, o, displayName)


def get_collaboration_for_service(connection, service):
    """ Given a service determine all COs that are part of it
    and return the found COs.

    Arguments:
        connection - An LDAP connection.
        service    - Service to find COs for

    Return:
        Dict of COs and their displayName.
    """

    r = connection.find(None,
                        "(&(objectClass=organization)(o=*))",
                        ['o', 'description'],
                        ldap.SCOPE_ONELEVEL
                       )
    cos = {}

    for dn, attributes in r.items():
        rdns = util.dn2rdns(dn)
        co_id = dn

        l = {}
        for name, value in attributes.items():
            if 'description' in name:
                l[name] = value[0]

        cos["{}".format(co_id)] = l

    return cos


def read_config_file():
    """Read a YAML config file."""

    if len(sys.argv) < 2:
        print("Missing config file.")
        print("usage: {} <config_file.yml>".format(sys.argv[0]))
        sys.exit(2)

    with open(sys.argv[1]) as f:
        config = yaml.safe_load(f)

    return config


def read_key_from_config(config, key):
    """
    Recursively find the key in the config file and return the
    associated value.
    """

    if type(key) is str:
        if key not in config:
            raise KeyError("{} not found in config file.".format(key))
        return config[key]

    k, v = next(iter(key.items()))
    a = read_key_from_config(config[k], v)

    return a


def get_service_from_config(config):
    """Get the service identifier from the config."""
    value = read_key_from_config(config, {'ldap': {'src': 'basedn'}})

    return util.dn2rdns(value)['dc'][0]


def generate_dest_people_entry_from_src_entry(dn, attributes):
    rdns = util.dn2rdns(dn)
    uid = rdns['uid'][0]

    dst_entry = {}
    dst_entry['objectClass'] = ['inetOrgPerson', 'person', 'posixAccount']
    dst_entry['uid'] = [uid]
    dst_entry['cn'] = attributes['cn']
    dst_entry['sn'] = attributes['sn']
    dst_entry['homeDirectory'] = attributes['homeDirectory']
    dst_entry['uidNumber'] = attributes['uidNumber']
    dst_entry['gidNumber'] = attributes['gidNumber']

    if 'sshPublicKey' in attributes:
        dst_entry['objectClass'].append('ldapPublicKey')
        dst_entry['sshPublicKey'] = attributes['sshPublicKey']

    if 'eduPersonPrincipleName' in attributes:
        dst_entry['objectClass'].append('eduPerson')
        dst_entry['eduPersonPrincipleName'] = attributes['eduPersonPrincipleName']

    if 'mail' in attributes:
        dst_entry['mail'] = attributes['mail']

    return uid, dst_entry


def generate_dest_group_entry_from_src_entry(attributes):
    dst_entry = {}
    cn = attributes['cn'][0]
    dst_entry['objectClass'] = ['posixGroup']
    dst_entry['gidNumber'] = attributes['gidNumber']
    dst_entry['cn'] = [cn]

    return dst_entry


def sync_rsc_with_scz(src_ldap, dst_ldap, collaborations):
    for k,v in collaborations.items():
        o = util.dn2rdns(k)['o'][0]

        src_entry = src_ldap.rfind(
            "ou=People,o={}".format(o),
            "(objectClass=person)"
        )

        for dn, attributes in src_entry.items():
            uid, dst_entry = generate_dest_people_entry_from_src_entry(dn, attributes)

            dst_dns = dst_ldap.rfind(
                "ou=People,o={},ou=COs".format(o),
                "(&(objectClass=person)(uid={}))".format(uid)
            )

            if len(dst_dns) == 1:
                dst_dn, old_entry = list(dst_dns.items())[0]
                new_entry = old_entry.copy()
                for attribute, value in dst_entry.items():
                    new_entry[attribute] = value
                ldif = dst_ldap.modify(dst_dn, old_entry, new_entry)
            elif len(dst_dns) == 0:
                dst_dn = "uid={},ou=People,o={},ou=COs,{}".format(
                    uid,
                    o,
                    dst_ldap.basedn
                )
                ldif = dst_ldap.add(dst_dn, dst_entry)
            else:
                print("Too many destination dns.")

        src_dns = src_ldap.rfind(
            "ou=Groups,o={}".format(o),
            "(objectClass=posixGroup)",
            ['gidNumber', 'cn']
        )

        group_dns = dst_ldap.rfind(
            "ou=Groups,o={},ou=COs".format(o),
            "(objectClass=posixGroup)"
        )

        for dn, attributes in src_dns.items():
            dst_entry = generate_dest_group_entry_from_src_entry(attributes)

            dst_dn = "cn={},ou=Groups,o={},ou=COs,{}".format(
                attributes['cn'][0],
                o,
                dst_ldap.basedn
            )
            if dst_dn not in group_dns:
                ldif = dst_ldap.add(dst_dn, dst_entry)


if __name__ == "__main__":
    """
    Connect to both the source and destination LDAP and sync the two.
    """

    config = read_config_file()

    src_ldap = Connection(read_key_from_config(config, {'ldap': 'src'}))
    dst_ldap = Connection(read_key_from_config(config, {'ldap': 'dst'}))

    service = get_service_from_config(config)
    collaborations = get_collaboration_for_service(src_ldap, service)

    build_dst_skeleton(config, dst_ldap, collaborations)

    sync_rsc_with_scz(src_ldap, dst_ldap, collaborations)
